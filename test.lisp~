#lang racket

(define (factoria x)
  (if (= x 1)
	1
	(* x (factoria (- x 1)))))

(define (reverse list1)
  (define (reverse-iter items result)
    (if (null? items)
      result
      (reverse-iter (cdr items) (cons (car items) result))))
    (reverse-iter list1 null))

(reverse (list 1 2 3 4))

(define (deep-reverse list1)
  (if (not (pair? list1))
      list1
    (reverse (map deep-reverse list1))))

(deep-reverse (list 1 2 (list 3 4) (list 5 6)))

;(define (fringe list1)
;  (if (not (pair? list1))
;      (list list1)
;    (append (fringe (car list1)) (fringe (cdr list1)))))

(define (fringe input)
  (cond ((null? input) null)
	((not (pair? input)) (list input))
	 (else (append (fringe (car input)) (fringe (cdr input))))))

(list 1 2)
(cons 1 2)
(car (list 1 2))
(cdr (list 1 2))
(car (cons 1 2))
(cdr (cons 1 2))

(define testlist (list 1 2 (list 3 (list 4 5) 6)))
(cdr testlist)
(cdr (cdr testlist))
(cdr (cdr (cdr testlist)))
(cdr (car (cdr (cdr testlist))))
(fringe (list 1 2 (list 3 (list 4 5) 6)))

(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch struct)
  (car struct))

(define (right-branch struct)
  (car (cdr struct)))

(define (branch-length branch)
  (car branch))

(define (branch-struct branch)
  (car (cdr branch)))

(define (total-weight struct)
  ((if (not (pair? struct))
       struct
     (+ (total-weight (left-branch struct))
	(total-weight (right-branch struct))))))

(define (is-balanced tree)
  (if (not (pair? tree))
      true
    (and (= ()))))
; TODO

(define (scale-tree-1 tree factor)
  (cond ((null? tree) null)
	((not (pair? tree)) (* tree factor))
	(else (cons (scale-tree (car tree) factor)
		    (scale-tree (cdr tree) factor)))))

(define (scale-tree-2 tree factor)
  (map (lambda (sub-tree))))
